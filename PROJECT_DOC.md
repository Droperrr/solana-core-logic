# Документация к проекту: Solana Enrich Pipeline

---

## Предисловие

Добро пожаловать в книгу о нашем проекте — системе enrich-парсинга и аналитики транзакций Solana. Эта документация написана для того, чтобы любой участник команды, аналитик, ML-инженер или просто интересующийся мог понять, как устроен наш пайплайн, как он развивается и какие задачи решает. Мы будем пополнять книгу по мере развития проекта, чтобы она всегда оставалась актуальной и полезной.

---

## Содержание

1. Архитектура и цели проекта
2. Обработка транзакций и event-based enrich-структуры
3. (Зарезервировано для следующих глав)

---

## Глава 1. Архитектура и цели проекта

### Зачем нужен этот проект?

Solana — одна из самых быстрых и популярных блокчейн-сетей. Но чтобы анализировать транзакции, строить ML-модели, выявлять аномалии и понимать поведение пользователей, нужны чистые, структурированные и обогащённые (enriched) данные. Наш проект — это универсальный пайплайн, который превращает «сырые» транзакции Solana в удобные для аналитики и машинного обучения event-based enrich-структуры.

### Ключевые задачи:
- Преобразование транзакций Solana в структурированные event-based enrich-объекты (`EnrichedEvent`).
- Приведение всех данных к единому стилю (snake_case, строгая типизация).
- Сопоставление enrich-структур с эталоном Solscan для максимальной совместимости.
- Гарантия качества данных (qc_tags, автотесты, схемы).
- Поддержка downstream-аналитики и ML.

### Архитектурные принципы:
- **Event-based**: каждая инструкция транзакции превращается в один или несколько атомарных событий (`EnrichedEvent`).
- **Flat & ML-ready**: все enrich-структуры плоские, легко сериализуются в Pandas/Parquet и поддерживают downstream-ML.
- **Прозрачность**: все преобразования и enrich-функции легко читаются и тестируются.
- **Масштабируемость**: легко добавлять новые типы событий и enrich-структуры.
- **Валидация**: автотесты и схемы гарантируют, что enrich-данные всегда соответствуют эталону.

---

## Глава 2. Обработка транзакций и event-based enrich-структуры

### Как работает пайплайн?

1. **Получение транзакции**: на вход подаётся сырая транзакция Solana (по сигнатуре или из дампа).
2. **Парсинг инструкций**: каждая инструкция разбирается на составные части (mint, transfer, swap, createAccount и т.д.).
3. **Enrich-функции**: для каждой инструкции вызывается enrich-функция, которая формирует один или несколько объектов `EnrichedEvent` (event-based модель).
4. **Приведение к snake_case**: все ключи и вложенные структуры приводятся к единому стилю.
5. **QC-блок**: enrich-структура содержит поле `qc_tags` — список тегов качества из централизованного справочника (см. qc/qc_catalog.py).
6. **Сохранение и аналитика**: enrich-структуры сохраняются в базу или передаются в downstream-аналитику/ML.

### Пример event-based enrich-структуры (EnrichedEvent):

```json
{
  "event_id": "5Y...abc:0:-1:0",
  "tx_signature": "5Y...abc",
  "event_type": "SWAP",
  "protocol": "Raydium",
  "instruction_type": "swapBaseIn",
  "slot": 123456,
  "block_time": 1680000000,
  "parser_version": "raydium-3.0.0",
  "initiator": "7G...xyz",
  "involved_accounts": ["7G...xyz", "9H...def", ...],
  "token_a_mint": "So11111111111111111111111111111111111111112",
  "token_a_amount_change": -1000000,
  "token_b_mint": "USDC...",
  "token_b_amount_change": 2500000,
  "liquidity_change_type": null,
  "liquidity_provider": null,
  "transfer_source": null,
  "transfer_destination": null,
  "transfer_mint": null,
  "transfer_amount": null,
  "staking_validator": null,
  "staking_amount": null,
  "token_flows": [
    {"direction": "OUT", "account": "7G...xyz", "owner": "7G...xyz", "mint": "So111...", "amount": 1000000, "account_tags": [], "owner_tags": ["FEE_PAYER"]},
    {"direction": "IN", "account": "7G...xyz", "owner": "7G...xyz", "mint": "USDC...", "amount": 2500000, "account_tags": [], "owner_tags": ["FEE_PAYER"]}
  ],
  "qc_tags": ["SWAP_SUCCESS"],
  "raw_instruction": {"programId": "...", "accounts": [...], "data": "...", "outer_index": 0, "is_inner": false, "inner_index": -1}
}
```

### QC-блок и обработка ошибок

- Теперь QC — это поле `qc_tags`: список тегов качества из справочника (см. qc/qc_catalog.py).
- Примеры тегов: `SWAP_SUCCESS`, `LIQUIDITY_ADD_PARTIAL`, `SWAP_IN_OUT_MISSING`, `UNSUPPORTED_INSTRUCTION`.
- enrich-структура всегда содержит qc_tags, даже если ошибок не было (например, `["SWAP_SUCCESS"]`).

### Преимущества event-based подхода
- **Гибкость**: легко добавлять новые типы событий и enrich-структуры.
- **Трассируемость**: каждое событие имеет уникальный event_id, привязанный к конкретной инструкции.
- **ML-готовность**: flat-структуры легко сериализуются в Pandas/Parquet, поддерживают feature engineering и downstream-аналитику.
- **Прозрачность и контроль качества**: qc_tags позволяют быстро фильтровать и анализировать качество данных.

---

(Следующие главы будут добавляться по мере развития проекта) 


## Декодер транзакций

Система использует автономный модуль декодера (`decoder`) для обработки транзакций Solana. Этот модуль реализует полный пайплайн от нормализации до обогащения данных:

1. **Нормализация (Normalize)**: Стандартизирует формат сырых данных транзакций.
2. **Парсинг (Parse)**: Интерпретирует инструкции на основе программно-специфических схем.
3. **Разрешение (Resolve)**: Преобразует разобранные инструкции в семантические бизнес-события.
4. **Обогащение (Enrich)**: Добавляет производные признаки для ML-анализа.

Декодер поддерживает следующие протоколы:
- System Program (`CreateAccount`, etc.)
- SPL Token (`transfer`, `mintTo`, `burn`, `closeAccount`)
- Raydium AMM (`Swap`)
- Jupiter
- Orca
- Pump.fun

### Расширенная поддержка Cross-Program Invocation (CPI)

Декодер включает специализированный алгоритм для обработки сложных транзакций с вложенными инструкциями (CPI):

- **Анализ иерархии вложенности**: Полный разбор дерева вложенных инструкций с сохранением связей между родительскими и дочерними инструкциями.
- **Определение семантических операций**: Идентификация и агрегация связанных инструкций в единые семантические события, такие как SWAP через агрегаторы.
- **Точное определение изменений токенов**: Алгоритм анализирует preTokenBalances/postTokenBalances для корректного определения входящих и исходящих токенов даже в самых сложных транзакциях.
- **Поддержка мультихоп свопов**: Корректная обработка многоэтапных свопов через различные пулы ликвидности.

#### Поддерживаемые типы транзакций с CPI:
- Свопы через Jupiter (v2-v4)
- Свопы через Raydium
- Свопы через кастомные агрегаторы и роутеры
- Многоэтапные транзакции с последовательными свопами

Подробная документация декодера находится в [decoder/README.md](decoder/README.md).

### Этап 3: Resolution (Разрешение)

На этом этапе сырые, но уже структурированные инструкции обогащаются бизнес-логикой. Система пытается понять *семантику* происходящего.

- **Resolver Chain**: Используется цепочка "резолверов" с установленным приоритетом. Каждый резолвер — это эксперт по определенному протоколу или типу операций (например, `RaydiumSwapResolver`, `TransferResolver`).
- **Hybrid Swap Detection**: Ключевым компонентом является `GenericSwapResolver`. Он использует гибридный подход для надежного определения обменов:
    1.  **Анализ `innerInstructions` (CPI)**: Сначала резолвер ищет стандартные паттерны кросс-программных вызовов, характерные для агрегаторов типа Jupiter.
    2.  **Анализ `pre/postTokenBalances`**: Если анализ CPI не дал результата (например, в транзакциях без `innerInstructions`), резолвер переключается на анализ изменений балансов кошелька до и после транзакции. Этот "fallback"-механизм позволяет обнаруживать даже непрямые обмены.
- **On-Chain Price Engine**: Для определения цен и объемов в обменах используется `OnChainPriceEngine`, который может запрашивать состояние пулов ликвидности напрямую из блокчейна.

Результатом этого этапа является список бизнес-событий (`BusinessEvent`), таких как `SWAP`, `TRANSFER`, `LIQUIDITY_ADD` и др.
